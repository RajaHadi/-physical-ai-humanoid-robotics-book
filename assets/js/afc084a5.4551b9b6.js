"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[1237],{2e3:(i,e,n)=>{n.r(e),n.d(e,{assets:()=>r,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"digital-twin/08-linking-modules","title":"Linking Modules","description":"Understanding the connections between Module 1 (ROS 2), Module 2 (Digital Twin), and Module 3 (Isaac Sim).","source":"@site/docs/digital-twin/08-linking-modules.md","sourceDirName":"digital-twin","slug":"/digital-twin/08-linking-modules","permalink":"/-physical-ai-humanoid-robotics-book/docs/digital-twin/08-linking-modules","draft":false,"unlisted":false,"editUrl":"https://github.com/RajaHadi/-physical-ai-humanoid-robotics-book/tree/main/docs/digital-twin/08-linking-modules.md","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"id":"08-linking-modules","title":"Linking Modules","sidebar_label":"Module Connections","description":"Understanding the connections between Module 1 (ROS 2), Module 2 (Digital Twin), and Module 3 (Isaac Sim)."},"sidebar":"tutorialSidebar","previous":{"title":"Best Practices","permalink":"/-physical-ai-humanoid-robotics-book/docs/digital-twin/07-best-practices"},"next":{"title":"01 - Introduction to NVIDIA Isaac Sim","permalink":"/-physical-ai-humanoid-robotics-book/docs/isaac-sim/introduction"}}');var s=n(4848),t=n(8453);const a={id:"08-linking-modules",title:"Linking Modules",sidebar_label:"Module Connections",description:"Understanding the connections between Module 1 (ROS 2), Module 2 (Digital Twin), and Module 3 (Isaac Sim)."},l="Linking Modules: ROS 2, Digital Twins, and Isaac Sim",r={},d=[{value:"From ROS 2 (Module 1) to Digital Twins (Module 2)",id:"from-ros-2-module-1-to-digital-twins-module-2",level:2},{value:"Preparing for Isaac Sim (Module 3)",id:"preparing-for-isaac-sim-module-3",level:2}];function c(i){const e={h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...i.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"linking-modules-ros-2-digital-twins-and-isaac-sim",children:"Linking Modules: ROS 2, Digital Twins, and Isaac Sim"})}),"\n",(0,s.jsx)(e.p,{children:"This module on Digital Twins forms a critical bridge in our journey through Physical AI and Humanoid Robotics. It builds directly upon the foundational knowledge established in Module 1 (ROS 2) and sets the stage for the advanced simulation topics covered in Module 3 (NVIDIA Isaac Sim)."}),"\n",(0,s.jsx)(e.h2,{id:"from-ros-2-module-1-to-digital-twins-module-2",children:"From ROS 2 (Module 1) to Digital Twins (Module 2)"}),"\n",(0,s.jsx)(e.p,{children:'Module 1 introduced ROS 2 as the "nervous system" for controlling real or simulated robots. In this module, we\'ve explored how a Digital Twin provides the "body" for that nervous system.'}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"URDF/SDF Models"}),": The URDF models developed in Module 1 for robot description are directly used as the basis for creating simulated robots in Gazebo and Unity within this module. The concepts of links, joints, and kinematic chains are fundamental to both."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"ROS 2 Communication"}),": The ROS 2 topics, services, and actions learned in Module 1 are the primary means by which a control system (either real or simulated) communicates with the Digital Twin's physics engine and sensors. The AI-to-ROS bridge from Module 1 is directly applicable to interfacing with a simulated robot."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Control Loops"}),": The control loops developed using ROS 2 in Module 1 can be seamlessly integrated with the Digital Twin. Instead of publishing to real hardware, commands are sent to the simulated robot, and sensor feedback is received from the simulated sensors."]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"preparing-for-isaac-sim-module-3",children:"Preparing for Isaac Sim (Module 3)"}),"\n",(0,s.jsx)(e.p,{children:"NVIDIA Isaac Sim, a powerful robotics simulation platform built on NVIDIA Omniverse, represents the next level of realistic and scalable simulation. This module on Digital Twins provides essential conceptual and practical groundwork for it."}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Physics Fundamentals"}),": The principles of rigid body dynamics, gravity, and friction discussed here are universal to all physics engines, including Isaac Sim's PhysX. Understanding these basics makes adapting to Isaac Sim's specific configuration straightforward."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Sensor Modeling"}),": The concepts of realistic sensor noise, resolution, and update rates explored in this module are directly transferable to configuring and interpreting data from Isaac Sim's advanced sensor models (e.g., RTX-powered LiDAR, high-fidelity cameras)."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"URDF/SDF for Complex Models"}),": Isaac Sim natively supports URDF and USD (Universal Scene Description) for robot and environment modeling. The experience gained here with URDF/SDF will directly translate to building and modifying robots in Isaac Sim."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Simulation Performance"}),": Discussions on managing latency and optimizing simulation performance are crucial preparation for working with high-fidelity, large-scale simulations in Isaac Sim."]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"By mastering the concepts and techniques in this Digital Twin module, you are well-equipped to leverage the full power of advanced simulation platforms like Isaac Sim for cutting-edge Physical AI and humanoid robotics research and development."})]})}function u(i={}){const{wrapper:e}={...(0,t.R)(),...i.components};return e?(0,s.jsx)(e,{...i,children:(0,s.jsx)(c,{...i})}):c(i)}},8453:(i,e,n)=>{n.d(e,{R:()=>a,x:()=>l});var o=n(6540);const s={},t=o.createContext(s);function a(i){const e=o.useContext(t);return o.useMemo(function(){return"function"==typeof i?i(e):{...e,...i}},[e,i])}function l(i){let e;return e=i.disableParentContext?"function"==typeof i.components?i.components(s):i.components||s:a(i.components),o.createElement(t.Provider,{value:e},i.children)}}}]);